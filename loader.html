<!DOCTYPE html>
<html class="sl-theme-dark" lang="en">
	<head>
    <meta charset="UTF-8">
		<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1196675595992085"
     crossorigin="anonymous"></script>
		<!-- initialize externals -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script>
		<script src=" https://cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js "></script>

		<!-- initialize my stuff -->
		<script src="/js/all.min.js"></script>
		<script src="/js/main.js"></script>
		<script src="/js/gaming-navbar.js"></script>

		<link rel="stylesheet" href="/style.css" />
		<link rel="stylesheet" href="/css/gaming-theme.css" />
		<link rel="manifest" href="/manifest.json" />

		<!-- seo + other things -->
		<title>Game Loader | Nova Hub</title>
		<link rel="icon" href="/nova-favicon.ico" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1196675595992085" crossorigin="anonymous"></script>
	</head>
	<body class="gaming-theme" id="noscroll">
		<header style="display: none;">
			<a href="/index.html">Home</a>
			<a href="/bookmarklets.html">Bookmarklets</a>
			<a href="/projects.html">Games</a>
			<a href="/apps.html">Apps</a>
			<a href="/settings.html">Settings</a>
			<a id="blank" href="#">Open Blank</a>
			<a href="/u/" class="usericon"><img src="/img/user.svg" /></a>
		</header>
		
		<main class="game-loader-main">
			<div class="game-preview-container">
				<iframe id="gameFrame" class="game-preview-iframe" allow="fullscreen; autoplay" sandbox="allow-downloads allow-forms allow-modals allow-pointer-lock allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox"></iframe>
				<div class="game-blur-overlay"></div>
				
				<!-- Centered Play Button -->
				<div class="game-play-overlay">
					<button id="playButton" class="game-play-button">
						Play Now
					</button>
				</div>
				
				<!-- Bottom Bar -->
				<div class="game-bottom-bar">
					<div class="game-title-bar">
						<span id="gameName" class="game-title-text">Loading Game...</span>
					</div>
					<div class="game-controls-bar">
						<button id="reloadGameButton" class="game-fullscreen-button" title="Reload game if it&#39;s stuck loading">
							<span>↻</span>
							<span>Reload</span>
						</button>
						<button id="fullscreenButton" class="game-fullscreen-button">
							<span class="fullscreen-icon">⛶</span>
							<span>Fullscreen</span>
						</button>
					</div>
				</div>
			</div>
			
			<!-- Ad spaces -->
			<div class="game-ads-container">
				<div class="game-ad-space" id="adSpace1"></div>
				<div class="game-ad-space" id="adSpace2"></div>
			</div>
			
			<!-- Recommended Games Section (right side) -->
			<div class="recommended-games-section" id="recommendedSection">
				<h2 class="recommended-title">We think you might like</h2>
				<div class="recommended-games-grid" id="recommendedGames"></div>
			</div>
		</main>

		<script>
		const GAMES_BASE_URL = window.location.origin;
		
		let gameData = null;
		let allGames = [];
		let isFullscreen = false;
		let isPlaying = false;
		
		function parseGameFromHash() {
			if (document.location.hash) {
				try {
					gameData = JSON.parse(decodeURIComponent(atob(document.location.hash.substring(1))));
					// Save to cookie instead of localStorage
					setCookie("selenite.lastGame", document.location.hash.substring(1));
					// Don't clear hash immediately - let it stay for navigation
					return gameData;
				} catch (e) {
					console.error("Error parsing game data:", e);
					return null;
				}
			} else {
				// Try cookie first, then fallback to localStorage for migration
				let lastGameHash = getCookie("selenite.lastGame");
				if (!lastGameHash) {
					// Migration: check localStorage and move to cookie
					const localStorageGame = localStorage.getItem("selenite.lastGame");
					if (localStorageGame) {
						lastGameHash = localStorageGame;
						setCookie("selenite.lastGame", lastGameHash);
						localStorage.removeItem("selenite.lastGame"); // Remove after migration
					}
				}
				if (lastGameHash) {
					try {
						gameData = JSON.parse(decodeURIComponent(atob(lastGameHash)));
						return gameData;
					} catch (e) {
						console.error("Error loading last game:", e);
						return null;
					}
				}
			}
			return null;
		}
		
		function initializeGame() {
			// Reset playing state
			isPlaying = false;
			isFullscreen = false;
			document.body.classList.remove("fullscreen-mode");
			
			// Clear the iframe src to stop the old game
			const gameFrame = document.getElementById("gameFrame");
			if (gameFrame) {
				gameFrame.removeAttribute("src");
				gameFrame.removeAttribute("data-src");
			}
			
			// Remove playing class from container
			const previewContainer = document.querySelector(".game-preview-container");
			if (previewContainer) {
				previewContainer.classList.remove("playing");
			}
			
			// Remove playing class from body
			document.body.classList.remove("game-playing");
			
			// Show overlays again
			const blurOverlay = document.querySelector(".game-blur-overlay");
			const playOverlay = document.querySelector(".game-play-overlay");
			if (blurOverlay) {
				blurOverlay.style.display = "";
				blurOverlay.style.opacity = "1";
				blurOverlay.style.visibility = "visible";
				blurOverlay.style.pointerEvents = "none";
				blurOverlay.style.transition = "";
			}
			if (playOverlay) {
				playOverlay.style.display = "flex";
				playOverlay.style.opacity = "1";
				playOverlay.style.visibility = "visible";
				playOverlay.style.pointerEvents = "none";
				playOverlay.style.transition = "";
			}
			
			// Load all games to get recommendations
			if (allGames.length === 0) {
				$.getJSON("/data/games.json", function(data) {
					allGames = data;
					if (gameData) {
						loadGame(gameData);
						loadRecommendedGames(gameData[0]);
					}
				}).fail(function() {
					console.error("Failed to load games.json");
					if (gameData) {
						loadGame(gameData);
					}
				});
			} else {
				if (gameData) {
					loadGame(gameData);
					loadRecommendedGames(gameData[0]);
				}
			}
		}
		
		function clearHashWithoutEvent() {
			// Use replaceState so we don't fire hashchange (which would re-run initializeGame and kick the user)
			const clean = window.location.pathname + (window.location.search || '');
			if (window.history.replaceState) {
				window.history.replaceState(null, '', clean);
			}
		}
		
		document.addEventListener("DOMContentLoaded", () => {
			// Detect touch devices (like iPads) and allow scrolling if fullscreen isn't well supported
			const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
			const hasFullscreenSupport = document.documentElement.requestFullscreen || 
			                            document.documentElement.webkitRequestFullscreen ||
			                            document.documentElement.mozRequestFullScreen ||
			                            document.documentElement.msRequestFullscreen;
			
			// On touch devices without good fullscreen support, allow scrolling
			if (isTouchDevice && !hasFullscreenSupport) {
				document.body.style.overflow = 'auto';
				document.body.style.position = 'relative';
				document.body.style.height = 'auto';
				document.body.style.maxHeight = 'none';
			}
			
			// Parse game data from hash or cookie
			gameData = parseGameFromHash();
			
			// If no game data found, try to keep the last game from cookie one more time
			// This prevents redirect loop when cookie exists but parse failed
			if (!gameData) {
				const lastGameHash = getCookie("selenite.lastGame");
				if (lastGameHash) {
					try {
						gameData = JSON.parse(decodeURIComponent(atob(lastGameHash)));
						console.log("Loaded game from cookie:", gameData);
					} catch (e) {
						console.error("Error loading last game from cookie:", e);
						// Cookie might be corrupted, clear it
						removeCookie("selenite.lastGame");
					}
				}
			}
			
			// Only redirect if we truly have no game data
			// Don't redirect if we're already on the loader page and have game state
			if (!gameData) {
				console.log("No game data found, redirecting to /projects.html");
				// Small delay to avoid redirect loops during navigation
				setTimeout(() => {
					if (!gameData) {
						window.location.href = "/projects.html";
					}
				}, 100);
				return;
			}
			
			// Ensure cookie is set even if we loaded from hash (for next time)
			if (document.location.hash) {
				setCookie("selenite.lastGame", document.location.hash.substring(1));
			}
			
			// Clear hash without firing hashchange (avoids double init / kick)
			clearHashWithoutEvent();
			
			initializeGame();
			
			// Listen for hash changes (only when user clicks a recommended game)
			window.addEventListener("hashchange", () => {
				// Ignore empty hash – often set by same-origin games or other scripts; would re-run init and kick the user
				const h = document.location.hash;
				if (!h || h === "#") return;
				const newGameData = parseGameFromHash();
				if (!newGameData) return;
				// Only init when switching to a different game; same game = avoid pointless reload/kick
				if (gameData && newGameData[0] === gameData[0]) return;
				gameData = newGameData;
				clearHashWithoutEvent();
				initializeGame();
			});
			
			// Play button - starts the game
			document.getElementById("playButton").addEventListener("click", () => {
				startGame();
			});
			
			// Reload button - reload game if stuck loading
			document.getElementById("reloadGameButton").addEventListener("click", () => {
				const gameFrame = document.getElementById("gameFrame");
				const baseSrc = gameFrame.getAttribute("data-src");
				if (baseSrc && isPlaying) {
					const sep = baseSrc.includes("?") ? "&" : "?";
					gameFrame.src = baseSrc + sep + "_t=" + Date.now();
				}
			});
			
			// Fullscreen button - browser fullscreen API
			document.getElementById("fullscreenButton").addEventListener("click", () => {
				toggleFullscreen();
			});
			
			// Listen for fullscreen changes
			document.addEventListener("fullscreenchange", updateFullscreenState);
			document.addEventListener("webkitfullscreenchange", updateFullscreenState);
			document.addEventListener("mozfullscreenchange", updateFullscreenState);
			document.addEventListener("MSFullscreenChange", updateFullscreenState);
		});
		
		function loadGame(game) {
			const source = game[3] || "semag";
			// Check if game has custom gameUrl (for external games)
			let gameUrl;
			if (game[4] && game[4].gameUrl) {
				gameUrl = game[4].gameUrl;
			} else if (source === "non-semag" || source === "Hypackel") {
				gameUrl = "/" + source + "/" + game[0] + "/index.html";
			} else {
				gameUrl = GAMES_BASE_URL + "/" + source + "/" + game[0] + "/index.html";
			}
			// Check if game data has custom imagePath (from games.json)
			// game[4] contains the full game object if available
			let gameImageUrl;
			if (game[4] && game[4].imagePath) {
				gameImageUrl = game[4].imagePath;
			} else {
				gameImageUrl = (source === "non-semag" || source === "Hypackel")
					? "/" + source + "/" + game[0] + "/" + decodeURIComponent(game[1])
					: GAMES_BASE_URL + "/" + source + "/" + game[0] + "/" + decodeURIComponent(game[1]);
			}
			const gameName = game[2];
			
			// Set game info
			document.getElementById("gameName").textContent = gameName;
			
			// Set game thumbnail as blurred background
			const previewContainer = document.querySelector(".game-preview-container");
			previewContainer.style.backgroundImage = `url("${gameImageUrl}")`;
			previewContainer.style.backgroundSize = "cover";
			previewContainer.style.backgroundPosition = "center";
			
			// Store URL but don't load until play is clicked
			const gameFrame = document.getElementById("gameFrame");
			gameFrame.setAttribute("data-src", gameUrl);
		}
		
		function loadRecommendedGames(currentDirectory) {
			// Filter out current game and pick 3 random games
			const otherGames = allGames.filter(game => game.directory !== currentDirectory);
			const shuffled = otherGames.sort(() => 0.5 - Math.random());
			const recommended = shuffled.slice(0, 3);
			
			const container = document.getElementById("recommendedGames");
			container.innerHTML = '';
			
			recommended.forEach(game => {
				const source = game.source || "semag";
				// semag uses hardcoded external URL, non-semag uses local paths for local development
				// Check for custom imagePath first
				let gameUrl = game.imagePath;
				if (!gameUrl) {
					gameUrl = (source === "non-semag" || source === "Hypackel")
						? "/" + source + "/" + game.directory + "/" + game.image
						: GAMES_BASE_URL + "/" + source + "/" + game.directory + "/" + game.image;
				}
				const gameLink = "/loader.html#" + btoa(encodeURIComponent(JSON.stringify([game.directory, game.image, game.name, source, game])));
				
				const gameCard = document.createElement("a");
				gameCard.href = gameLink;
				gameCard.className = "recommended-game-card";
				gameCard.innerHTML = `
					<img src="${gameUrl}" alt="${game.name}" class="recommended-game-image" />
					<h3 class="recommended-game-name">${game.name}</h3>
				`;
				container.appendChild(gameCard);
			});
		}
		
		function startGame() {
			if (!isPlaying) {
				isPlaying = true;
				const gameFrame = document.getElementById("gameFrame");
				const previewContainer = document.querySelector(".game-preview-container");
				const blurOverlay = document.querySelector(".game-blur-overlay");
				const playOverlay = document.querySelector(".game-play-overlay");
				
				// Load the game iframe – add cache-busting to avoid stuck "loading" on first load
				const baseSrc = gameFrame.getAttribute("data-src");
				if (baseSrc) {
					const sep = baseSrc.includes("?") ? "&" : "?";
					gameFrame.src = baseSrc + sep + "_t=" + Date.now();
				}
				
				// Add playing class to container for CSS targeting
				previewContainer.classList.add("playing");
				// Add playing class to body to lock document height
				document.body.classList.add("game-playing");
				
				// Remove background image and blur overlay with smooth transition
				previewContainer.style.backgroundImage = "none";
				if (blurOverlay) {
					blurOverlay.style.opacity = "0";
					blurOverlay.style.transition = "opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), visibility 0s linear 0.6s";
				}
				if (playOverlay) {
					playOverlay.style.opacity = "0";
					playOverlay.style.transition = "opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), visibility 0s linear 0.6s";
				}
				
				// Hide overlays completely after transition
				setTimeout(() => {
					if (blurOverlay) {
						blurOverlay.style.display = "none";
						blurOverlay.style.visibility = "hidden";
						blurOverlay.style.pointerEvents = "none";
					}
					if (playOverlay) {
						playOverlay.style.display = "none";
						playOverlay.style.visibility = "hidden";
						playOverlay.style.pointerEvents = "none";
					}
				}, 600);
			}
		}
		
		function toggleFullscreen() {
			const previewContainer = document.querySelector(".game-preview-container");
			
			if (!previewContainer) {
				return;
			}
			
			// Check if we're currently in fullscreen
			const isCurrentlyFullscreen = !!(
				document.fullscreenElement ||
				document.webkitFullscreenElement ||
				document.mozFullScreenElement ||
				document.msFullscreenElement
			);
			
			if (isCurrentlyFullscreen) {
				// Exit fullscreen
				exitFullscreen();
			} else {
				// Enter fullscreen
				enterFullscreen(previewContainer);
			}
		}
		
		function enterFullscreen(element) {
			// Start game if not already playing
			if (!isPlaying) {
				startGame();
			}
			
			// Request fullscreen with cross-browser support
			if (element.requestFullscreen) {
				element.requestFullscreen().then(() => {
					updateFullscreenState();
				}).catch((err) => {
					console.error("Error entering fullscreen:", err);
				});
			} else if (element.webkitRequestFullscreen) {
				element.webkitRequestFullscreen();
				updateFullscreenState();
			} else if (element.mozRequestFullScreen) {
				element.mozRequestFullScreen();
				updateFullscreenState();
			} else if (element.msRequestFullscreen) {
				element.msRequestFullscreen();
				updateFullscreenState();
			} else {
				console.warn("Fullscreen API not supported in this browser");
			}
		}
		
		function exitFullscreen() {
			if (document.exitFullscreen) {
				document.exitFullscreen().then(() => {
					updateFullscreenState();
				}).catch((err) => {
					console.error("Error exiting fullscreen:", err);
				});
			} else if (document.webkitExitFullscreen) {
				document.webkitExitFullscreen();
				updateFullscreenState();
			} else if (document.mozCancelFullScreen) {
				document.mozCancelFullScreen();
				updateFullscreenState();
			} else if (document.msExitFullscreen) {
				document.msExitFullscreen();
				updateFullscreenState();
			}
		}
		
		function updateFullscreenState() {
			const isCurrentlyFullscreen = !!(
				document.fullscreenElement ||
				document.webkitFullscreenElement ||
				document.mozFullScreenElement ||
				document.msFullscreenElement
			);
			
			isFullscreen = isCurrentlyFullscreen;
			const fullscreenButton = document.getElementById("fullscreenButton");
			const buttonText = fullscreenButton.querySelector("span:last-child");
			
			if (fullscreenButton && buttonText) {
				if (isCurrentlyFullscreen) {
					document.body.classList.add("fullscreen-mode");
					buttonText.textContent = "Exit Fullscreen";
					fullscreenButton.classList.add("active");
				} else {
					document.body.classList.remove("fullscreen-mode");
					buttonText.textContent = "Fullscreen";
					fullscreenButton.classList.remove("active");
				}
			}
		}
		
		// Exit fullscreen when pressing ESC (handled by browser, but we update state)
		document.addEventListener("keydown", (e) => {
			if (e.key === "Escape") {
				// Browser handles ESC automatically, just update our state
				setTimeout(updateFullscreenState, 100);
			}
		});
		</script>
	</body>
</html>
